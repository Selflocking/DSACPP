# Vector

## 查找

考虑这样的代码

```c++
//二分查找A
template<typename T>
static Rank binSearch(T *A, const T &e, Rank lo, Rank hi) {
while (lo < hi) {
Rank mi = lo + (hi - lo) / 2; //防止爆int
if (e < A[mi]) hi = mi;
else if (e > A[mi]) lo = mi + 1;
else return mi;
}
return -1;
} 
```

发现问题没有，

1. 当传进来的向量中有多个重复的数时，返回的秩时“随机”的
2. 需要1次比较跳到左半边，需要2次比较跳到右半边，所以其实左右比较长度不一样长

这个二分算法的时间复杂度为O($1.5log_2n$),有一个常系数1.5

下面的二分就完美地解决了这两个问题

```c++
template<typename T>
static Rank binSearch(T *A, const T &e, Rank lo, Rank hi) {
    while (lo < hi) {
        Rank mi = lo + (hi - lo) / 2;
        if (e < A[mi]) hi = mi;
        else lo = mi + 1;
    }
    return lo - 1;
}
```

额，虽然这个代码跳过了mi，但是如果传进来数组的中间值仍然可以返回正确的答案，但是这个函数的返回值有点反人类，代表的意义是不大于e的最大值。
所以如果要匹配的值小于数组中所有元素，那么返回值为-1，如果大于所有元素，返回值为size()-1。
举个例子，如果数组为1 2 3 4 5，lo = 0，hi = 5;
如果e = -10，返回值为-1
如果e = 5，返回值为4
如果e = 10，返回值还是4，因为返回值是不大于e的最大值，有点反人类

## 比较树模型

考虑这样一个问题，有三个苹果，其中两个质量相等，一个与其它两个不相等，请找出那个质量不相等的苹果。
正确代码如下

```c++
fun(){
    if(A==B) return C;
    else if(A==C) return B;
    else return A; 
}
```

它的比较树模型如下

```text
            |
      --Y--A=B?--N--
      |            |
      C      --Y--A=C?--N--
             |            |
             B            A
```

不难理解，无论什么算法，只要它的结果都是取决于不同变量或常量之间的比较，这类算法都可以用比较树描述，都称作基于比较式算法(comparison-based algorithm),简称CBA算法。

找不同质量苹果这个问题的每个子问题都是一个判等操作，返回值为True或False，只有两种，所以它的比较树是一棵二叉树，二叉树的叶子节点即问题的解。

已知对于高度为h的二叉树，它的叶子节点不可能超过$2^n$,相应的对于有N种结果的问题，比较树的高度不会小于$\lceil log_{2}{N} \rceil$，易知我们的找苹果算法已是最优。

考虑基于比较的排序算法，可能的输出有$n!$种，每一次比较结果为<,>或=, 或者<和>=.
按照比较结果为三种来看待, 基于比较的排序算法的比较树为三叉树, 树高不应低于$\lceil log_{3}{n!} \rceil$ = $nlogn$. (Stirling逼近公式)

故对于CBA排序算法，时间复杂度为$nlog$已是最优

## 排序的稳定性

一个向量A利用某种算法排序后，A中的每对相等的元素之间的位置没有变化，就称这个排序算法是稳定的。